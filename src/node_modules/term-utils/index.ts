// ANSI Regex from @jamen on Github
export const ansiRegex = /\x1B[\x40-\x5F]([\x30-\x3F]*[\x20-\x2F])*[\x30-\x3F]*[\x40-\x7E]/g;

export function stripAnsi(string: string) {
  return string.replace(ansiRegex, "");
}

export function sliceAnsi(string: string, start = 0, end: number = undefined, reset = false, verbose = true) {
  // Empty string
  if (string.length === 0) {
    return "";
  }

  const codes: [string, number, number][] = [
    ["", 0, 0],
  ];
  ansiRegex.lastIndex = 0;
  const undefinedEnd = end === undefined;

  let totalAnsiLength = 0;
  let code: RegExpExecArray;
  let startCode = 0; // Start code item index
  let setStart = false;
  let endCode = -1; // Set to nonexistant end code item index until one is actually found

	// Loop over all escape codes you can find in the string
  while (code = ansiRegex.exec(string)) {
		const codeValue = code[0];
    const curCode: [string, number, number] = [
      codeValue,
      code.index,
      code.index - totalAnsiLength, // "Printable" char count relative to this code
    ];

    codes.push(curCode);
    totalAnsiLength += codeValue.length;
  }

	// Remap any negative start/end indexes
	if (start < 0 || end < 0) {
		const lastCode = codes[codes.length - 1];
		const rawStringLength = lastCode
													  ? lastCode[2] + string.length - (lastCode[1] + lastCode[0].length)
														: string.length;

		if (start < 0) {
			start = Math.max(rawStringLength + start, 0);
		}

		if (end < 0) {
			end = Math.max(rawStringLength + end, 0);
		}
	}

	if (!undefinedEnd && end < start || end === start) {
		// Invalid range
		return "";
	}

  let endTextCode = -1;
  let printableOffset = 0;

	// Find where start/end are relative to the escape codes
  // and find endTextCode if any
	for (let i=0; i<codes.length; i++) {
		const code = codes[i];

    if (!setStart) {
      if (code[2] >= start) {
        startCode = i;
        setStart = true;
      }
    } else {
      if (!undefinedEnd && code[2] <= end) {
        endCode = i;
      }
    }

    if (printableOffset !== code[2]) {
      endTextCode = i;
      printableOffset = code[2];
    }
	}

  // Confirm endTextCode
  let endTextCodeItem = codes[endTextCode];

  {
    const lastCode = codes[codes.length - 1];
    if (!(endTextCodeItem && lastCode[1] + lastCode[0].length === string.length)) {
      endTextCode = -1;
      endTextCodeItem = undefined;
    }
  }

	// verbose && console.log("CODES", codes);
	let out = "";
  let outInitialCodes = "";

	if (codes.length === 1) {
		// No escape codes here
		return string.slice(start, end);
	} else if (!setStart) {
		// Slice range is only after the escape codes
    if (endTextCodeItem) {
      // We have codes that continue to the end but the slice
      // range is after all the text which are before the codes,
      // so nothing to return here
      return "";
    }

		const lastCode = codes[codes.length - 1];
		const offset = lastCode[1] + lastCode[0].length + (start - lastCode[2]);

		for (const code of codes) {
			out += code[0];
		}

		if (!undefinedEnd) {
			out += string.slice(offset, offset + end - start);
		} else {
			out += string.slice(offset);
		}
	} else {
		// Slice range includes escape codes
	  let lastIndex = 0;
	  const startCodeItem = codes[startCode];
	  const endCodeItem = codes[endCode];

		// Calculate the index of the the "prefixText" (text to include before the start code) if any,
	  const prefixTextIndex = startCodeItem[1] - (startCodeItem[2] - start);

	  // Add initial ANSI codes
	  for (let i=0; i<startCode; i++) {
	    const code = codes[i];
	    outInitialCodes += code[0];
	  }

		// Calculate how much we should truncate if `end` is before the start code
		const beforeStart = undefinedEnd ? 0 : Math.max(startCodeItem[2] - end, 0);
    const prefixEnd = startCodeItem[1] - beforeStart;
	  out += string.slice(prefixTextIndex, endTextCodeItem ? Math.min(endTextCodeItem[1], prefixEnd) : prefixEnd);

		if (beforeStart) {
			// Slice range ends before the first start code
			// Nothing here, FIXME: Restructure this control flow
      outInitialCodes = "";
		} else if (undefinedEnd || !endCodeItem) {
			if (undefinedEnd) {
        const endTextCodeItem = codes[endTextCode];
        const end = endTextCodeItem ? endTextCodeItem[1] : string.length;

				// No end set
				out += string.slice(startCodeItem[1], end);
			} else {
				// No end code in slice range after start code
				const endSlice = startCodeItem[1] + startCodeItem[0].length + end - startCodeItem[2];
				out += string.slice(startCodeItem[1], endSlice);
			}
	  } else {
			// Slice range includes prefixText, middleText, and suffixText
      const middleEnd = endCodeItem[1] + endCodeItem[0].length;
	    const middleText = string.slice(startCodeItem[1], endTextCodeItem ? Math.min(endTextCodeItem[1], middleEnd) : middleEnd);

	    const suffixTextIndex = startCodeItem[1] + middleText.length;
	    const suffixTextLength = Math.max(end - endCodeItem[2], 0);
      const suffixEnd = suffixTextIndex + suffixTextLength;

      let suffix;
	    out += middleText;
	    out += suffix = string.slice(suffixTextIndex, endTextCodeItem ? Math.min(endCodeItem[1], suffixEnd) : suffixEnd);
	  }
	}

	return outInitialCodes + out + (reset ? "\u001b[0m" : "");
}

export function rightAlign(content: string, precedence = false) {
  return "\\]" + (precedence ? "R" : "r") + content;
}

export function strFill(string: string, cols: number) {
	let out = string;
	while (out.length < cols) out += string;

	return out.slice(0, cols);
}

export function strMultiply(string: string, count: number) {
	if (count <= 0) {
		return "";
	}

	let out = "";
	for (let i=0; i<count; i++) out += string;

	return out;
}
