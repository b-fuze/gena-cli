import {jSh} from "jshorts";

// ANSI Regex from @jamen on Github
export const ansiRegex = /\x1B[\x40-\x5F]([\x30-\x3F]*[\x20-\x2F])*[\x30-\x3F]*[\x40-\x7E]/g;

export function stripAnsi(string: string) {
  return string && string.replace(ansiRegex, "");
}

export interface SliceMeta {
  out: string;
  length: number;
  oldLength: number;
}

export function sliceAnsi(string: string, start?: number, end?: number, reset?: boolean, meta?: false): string;
export function sliceAnsi(string: string, start?: number, end?: number, reset?: boolean, meta?: true): SliceMeta;
export function sliceAnsi(string: string, start: number = 0, end: number = undefined, reset = false, meta = false) {
  // Empty string
  if (string.length === 0) {
    return meta ? {out: "", length: 0, oldLength: 0} : "";
  }

  const codes: [string, number, number][] = [
    ["", 0, 0],
  ];
  ansiRegex.lastIndex = 0;

  const undefinedEnd = end === undefined;
  const remapIndexes = start < 0 || end < 0;

  let totalAnsiLength = 0;
  let code: RegExpExecArray;
  let codeIndex = -1;
  let codeSearchStart = 0;
  let startCode = 0; // Start code item index
  let setStart = false;
  let endCode = -1; // Set to nonexistant end code item index until one is actually found

  let endTextCode = -1;
  let printableOffset = 0;

  // Code parsing specific
  // const maxOpenCode = 0x5F - 0x40;

  // Loop over all escape codes you can find in the string
  // Implemented via a regex written by @jamen on GitHub
  codeSearchLoop:
  while ((codeIndex = string.indexOf("\u001b", codeSearchStart)) !== -1) {
    let codeString = "\u001b";
    const cur = string[codeIndex + 1];
    const curCode = cur.charCodeAt(0);

    if (!(curCode >= 0x40 && curCode <= 0x5F)) {
      codeSearchStart = codeIndex + 1;
      continue codeSearchLoop;
    }

    codeString += cur;

    for (let i=codeIndex+2; i<string.length; i++) {
      const cur = string[i];
      const curCode = cur.charCodeAt(0);

      if (curCode >= 0x30 && curCode <= 0x3F || curCode >= 0x20 && curCode <= 0x2F) {
        // Do nothing
      } else if (curCode >= 0x40 && curCode <= 0x7E) {
        // Closing code
        codeString += cur;
        let code: [string, number, number];
        codes.push(code = [
          codeString,
          codeIndex,
          codeIndex - totalAnsiLength,
        ]);

        // Find where start/end are relative to the escape codes
        // and find endTextCode if any
        if (!remapIndexes) {
          const curCodeIndex = codes.length - 1;

          if (!setStart) {
            if (code[2] >= start) {
              startCode = curCodeIndex;
              setStart = true;
            }
          } else {
            if (!undefinedEnd && code[2] <= end) {
              endCode = curCodeIndex;
            }
          }

          if (printableOffset !== code[2]) {
            endTextCode = curCodeIndex;
            printableOffset = code[2];
          }
        }

        // Done
        totalAnsiLength += codeString.length;
        codeSearchStart = i + 1;
        continue codeSearchLoop;
      } else {
        codeSearchStart = i;
        continue codeSearchLoop;
      }

      codeString += cur;
    }
  }

	// Remap any negative start/end indexes
  const lastCode = codes[codes.length - 1];
  const rawStringLength = lastCode
    ? lastCode[2] + string.length - (lastCode[1] + lastCode[0].length)
    : string.length;

	if (remapIndexes) {
		if (start < 0) {
			start = Math.max(rawStringLength + start, 0);
		}

		if (end < 0) {
			end = Math.max(rawStringLength + end, 0);
		}
	}

	if (!undefinedEnd && end < start || end === start) {
		// Invalid range
		return meta ? {out: "", length: 0, oldLength: rawStringLength} : "";
	}

	// Find where start/end are relative to the escape codes
  // and find endTextCode if any
  if (remapIndexes) {
    for (let i=0; i<codes.length; i++) {
      const code = codes[i];

      if (!setStart) {
        if (code[2] >= start) {
          startCode = i;
          setStart = true;
        }
      } else {
        if (!undefinedEnd && code[2] <= end) {
          endCode = i;
        }
      }

      if (printableOffset !== code[2]) {
        endTextCode = i;
        printableOffset = code[2];
      }
    }
  }

  if (codes.length === 1) {
		// No escape codes here
		const sliced = string.slice(start, end);
    return meta ? {out: sliced, length: sliced.length, oldLength: string.length} : sliced;
	}

  // Confirm endTextCode, a code that could be followed by multiple ANSI codes
  // to the end of the string but no actual printed characters
  let endTextCodeItem = codes[endTextCode];

  {
    const lastCode = codes[codes.length - 1];
    if (!(endTextCodeItem && lastCode[1] + lastCode[0].length === string.length)) {
      endTextCode = -1;
      endTextCodeItem = undefined;
    }
  }

	// verbose && console.log("CODES", codes);
	let out = "";
  let outInitialCodes = "";
  let outLength = 0;

	if (!setStart) {
		// Slice range is only after the escape codes
    if (endTextCodeItem) {
      // We have codes that continue to the end but the slice
      // range is after all the text which are before the codes,
      // so nothing to return here
      return meta ? {out: "", length: 0, oldLength: rawStringLength} : "";
    }

		const lastCode = codes[codes.length - 1];
		const offset = lastCode[1] + lastCode[0].length + (start - lastCode[2]);

		for (const code of codes) {
			out += code[0];
		}

    const outCodeLength = out.length;

		if (!undefinedEnd) {
			out += string.slice(offset, offset + end - start);
		} else {
			out += string.slice(offset);
		}

    outLength = out.length - outCodeLength;
	} else {
		// Slice range includes escape codes
	  let lastIndex = 0;
	  const startCodeItem = codes[startCode];
	  const endCodeItem = codes[endCode];

		// Calculate the index of the the "prefixText" (text to include before the start code) if any,
	  const prefixTextIndex = startCodeItem[1] - (startCodeItem[2] - start);

	  // Add initial ANSI codes
	  for (let i=0; i<startCode; i++) {
	    const code = codes[i];
	    outInitialCodes += code[0];
	  }

		// Calculate how much we should truncate if `end` is before the start code
		const beforeStart = undefinedEnd ? 0 : Math.max(startCodeItem[2] - end, 0);
    const prefixEnd = startCodeItem[1] - beforeStart;
    const prefixEndIndex = endTextCodeItem ? Math.min(endTextCodeItem[1], prefixEnd) : prefixEnd;

	  out += string.slice(prefixTextIndex, prefixEndIndex);
    outLength += prefixEndIndex - prefixTextIndex;

		if (beforeStart) {
			// Slice range ends before the first start code
			// Nothing here, FIXME: Restructure this control flow
      outInitialCodes = "";
		} else if (undefinedEnd || !endCodeItem) {
			if (undefinedEnd) {
        const endTextCodeItem = codes[endTextCode];
        const end = endTextCodeItem ? endTextCodeItem[1] : string.length;

				// No end set
				out += string.slice(startCodeItem[1], end);

        // Calculate length
        // FIXME: There will prolly always be an `endTextCodeItem` here, see line 153 (No escape codes)
        if (endTextCodeItem) {
          outLength += endTextCodeItem[2] - startCodeItem[2];
        } else {
          outLength += end - (startCodeItem[1] + startCodeItem[0].length);
        }
			} else {
				// No end code in slice range after start code
				const endSlice = startCodeItem[1] + startCodeItem[0].length + end - startCodeItem[2];
				out += string.slice(startCodeItem[1], endSlice);
        outLength += endSlice - (startCodeItem[1] + startCodeItem[0].length);
			}
	  } else {
			// Slice range includes prefixText, middleText, and suffixText
      const middleEnd = endCodeItem[1] + endCodeItem[0].length;
      const middleEndIndex = endTextCodeItem ? Math.min(endTextCodeItem[1], middleEnd) : middleEnd;

      const middleText = string.slice(startCodeItem[1], middleEndIndex);
      outLength += Math.max((endTextCodeItem ? Math.min(endTextCodeItem[2], endCodeItem[2]) : endCodeItem[2]) - startCodeItem[2], 0); //middleEndIndex - (startCodeItem[1] + startCodeItem[0].length);

	    const suffixTextIndex = startCodeItem[1] + middleText.length;
	    const suffixTextLength = Math.max(end - endCodeItem[2], 0);
      const suffixEnd = suffixTextIndex + suffixTextLength;
      const suffixEndIndex = endTextCodeItem ? Math.min(endTextCodeItem[1], suffixEnd) : suffixEnd;

	    out += middleText;
      const suffixText = string.slice(suffixTextIndex, suffixEndIndex);

      out += suffixText;
      outLength += suffixText.length;
	  }
	}

	const fullOut = outInitialCodes + out + (reset ? "\u001b[0m" : "");
  return meta ? {out: fullOut, length: outLength, oldLength: rawStringLength} : fullOut;
}

export function forceAnsi(string: string, ansi: string) {
  return string.replace(/\u001b\[0m/g, "\u001b[0m" + ansi);
}

export function rightAlign(content: string, precedence = false) {
  return "\\]" + (precedence ? "R" : "r") + content;
}

export function center(content: string, cols: number) {
  const printable = stripAnsi(content).length;
  const space = Math.max(cols - printable, 0) / 2;

  return jSh.nChars(" ", Math.floor(space))
           + content
           + jSh.nChars(" ", Math.ceil(space));
}

export function strFill(string: string, cols: number) {
	let out = string;
	while (out.length < cols) out += string;

	return out.slice(0, cols);
}

export function strMultiply(string: string, count: number) {
	if (count <= 0) {
		return "";
	}

	let out = "";
	for (let i=0; i<count; i++) out += string;

	return out;
}
